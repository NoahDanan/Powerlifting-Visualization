<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powerlifting Visualization</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            background-color: #333; /* Dark grey background */
            color: #fff; /* White text */
            font-family: Arial, sans-serif; /* Added a font-family */
        }
        .data-text {
            fill: #fff;
            font-size: 48px; /* Increased font size */
            visibility: hidden;
        }
        .data-text--show {
            visibility: visible;
        }
        .legend-text {
            fill: #fff; /* Set legend color */
            font-size: 18px; /* Increased legend text size */
        }
        .slider-container {
            margin: 20px;
            text-align: center;
        }
        .slider {
            width: 80%;
        }
        .year-label {
            color: #fff;
            font-size: 20px;
        }
        .readme-container {
            margin: 20px;
            padding: 10px;
            background-color: #444; /* Darker grey background for README container */
            border-radius: 5px; /* Rounded corners */
        }
        .readme-container pre {
            white-space: pre-wrap; /* Allows text to wrap */
            font-size: 16px; /* Font size for README text */
            line-height: 1.5; /* Line height for better readability */
        }
    </style>
</head>
<body>
    <div class="slider-container">
        <label for="year-slider" class="year-label">Year: <span id="year-label">2004</span></label>
        <input type="range" id="year-slider" class="slider" min="2004" max="2014" value="2004" step="10">
    </div>
    <script>
        const datasets = {
            '2004': 'df_2004_mean.csv',
            '2014': 'df_2014_mean.csv'
        };

        function loadData(year) {
            const file = datasets[year];
            d3.csv(file).then(function(data) {
                const pieData = data.map(d => ({
                    name: d.WeightClassKg + 'kg',
                    value: +d.Dots,
                    color: getRandomColor()
                }));
                bakeDonut(pieData);
            }).catch(error => console.error('Error fetching data:', error));
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function bakeDonut(data) {
            d3.selectAll('svg').remove();

            // Sort data by value and keep only the top 10 entries
            const top10Data = data.sort((a, b) => b.value - a.value).slice(0, 10);

            let activeSegment;
            const viewWidth = 1000, // Increased width
                viewHeight = 800,
                svgWidth = viewHeight,
                svgHeight = viewHeight,
                thickness = 100, // Increased thickness
                colorArray = top10Data.map(k => k.color),
                el = d3.select('body'),
                radius = Math.min(svgWidth, svgHeight) / 2,
                color = d3.scaleOrdinal().range(colorArray);

            const max = d3.max(top10Data, (maxData) => maxData.value);

            const svg = el.append('svg')
                .attr('viewBox', `0 0 ${viewWidth + thickness} ${viewHeight + thickness}`)
                .attr('class', 'pie')
                .attr('width', viewWidth)
                .attr('height', svgHeight);

            const g = svg.append('g')
                .attr('transform', `translate(${(svgWidth / 2) + (thickness / 2)}, ${(svgHeight / 2) + (thickness / 2)})`);

            const arc = d3.arc()
                .innerRadius(radius - thickness)
                .outerRadius(radius);

            const arcHover = d3.arc()
                .innerRadius(radius - (thickness + 5))
                .outerRadius(radius + 8);

            const pie = d3.pie()
                .value(function(pieData) { return pieData.value; })
                .sort(null);

            const path = g.selectAll('path')
                .attr('class', 'data-path')
                .data(pie(top10Data))
                .enter()
                .append('g')
                .attr('class', 'data-group')
                .each(function(pathData, i) {
                    const group = d3.select(this);

                    group.append('text')
                        .text(`${pathData.data.value}`)
                        .attr('class', 'data-text data-text__value')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '1rem');

                    group.append('text')
                        .text(`${pathData.data.name}`)
                        .attr('class', 'data-text data-text__name')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '3.5rem');

                    // Set default active segment
                    if (pathData.value === max) {
                        d3.select(this).select('.data-text__value').classed('data-text--show', true);
                        d3.select(this).select('.data-text__name').classed('data-text--show', true);
                    }
                })
                .append('path')
                .attr('d', arc)
                .attr('fill', (fillData, i) => color(fillData.data.name))
                .attr('class', 'data-path')
                .on('mouseover', function() {
                    const _thisPath = this,
                        parentNode = _thisPath.parentNode;

                    if (_thisPath !== activeSegment) {
                        activeSegment = _thisPath;

                        d3.selectAll('.data-text').classed('data-text--show', false);

                        d3.selectAll('.data-path')
                            .transition()
                            .duration(250)
                            .attr('d', arc);

                        d3.select(_thisPath)
                            .transition()
                            .duration(250)
                            .attr('d', arcHover);

                        d3.select(parentNode).select('.data-text__value').classed('data-text--show', true);
                        d3.select(parentNode).select('.data-text__name').classed('data-text--show', true);
                    }
                })
                .each(function(v, i) {
                    if (v.value === max) {
                        d3.select(this).attr('d', arcHover);
                        activeSegment = this;
                    }
                    this._current = i;
                });

            const legendRectSize = 20; // Increased legend size
            const legendSpacing = 10;

            const legend = svg.selectAll('.legend')
                .data(color.domain())
                .enter()
                .append('g')
                .attr('class', 'legend')
                .attr('transform', function(legendData, i) {
                    const itemHeight = legendRectSize + legendSpacing;
                    const horz = svgWidth + 100; // Adjusted horizontal position further to the right
                    const vert = (i * itemHeight) + 20; // Adjusted vertical position
                    return `translate(${horz}, ${vert})`;
                });

            legend.append('rect') // Changed from circle to rect for better appearance
                .attr('width', legendRectSize)
                .attr('height', legendRectSize)
                .style('fill', color);

            legend.append('text')
                .attr('x', legendRectSize + legendSpacing)
                .attr('y', legendRectSize - legendSpacing / 2) // Lowered text slightly
                .attr('class', 'legend-text')
                .text((legendData) => legendData);
        }

        document.getElementById('year-slider').addEventListener('input', function() {
            const selectedYear = this.value;
            document.getElementById('year-label').textContent = selectedYear;
            loadData(selectedYear);
        });

        // Load initial data
        loadData('2004');

        // Fetch and display README content
        fetch('README.md') // Adjust the path if necessary
            .then(response => response.text())
            .then(text => {
                document.getElementById('readme-content').textContent = text;
            })
            .catch(error => console.error('Error fetching README:', error));
    </script>
    <div class="readme-container">
        <pre id="readme-content"></pre>
    </div>
</body>
</html>
